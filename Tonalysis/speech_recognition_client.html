<!DOCTYPE html>
<html>
<head>
    <title>Live Speech Recognition Client</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background: #000;
        }
        
        /* Main layout */
        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        /* Video container - full bleed */
        #videoContainer {
            flex: 1;
            position: relative;
            background: #000;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        /* Side panel */
        .side-panel {
            width: 320px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            padding: 16px;
            gap: 16px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        /* Status badge */
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 500;
            color: white;
            background: #DC2626;
            transition: all 0.2s ease;
        }
        
        .status-badge.connected {
            background: #059669;
        }
        
        .status-badge .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }
        
        /* Card style */
        .card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.2s ease;
        }
        
        .card:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        /* Typography */
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            margin: 0 0 12px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .card-content {
            font-size: 14px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }
        
        /* Transcription area */
        #currentTranscription { 
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            min-height: 60px; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
            overflow-y: auto;
            max-height: 120px;
        }
        
        .highlight { 
            background-color: rgba(59, 130, 246, 0.3);
            padding: 1px 2px;
            border-radius: 2px;
        }
        

        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: #3B82F6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563EB;
            transform: translateY(-1px);
        }
        
        .btn-primary.recording {
            background: #DC2626;
            animation: pulse 2s infinite;
        }
        
        .btn-primary.recording:hover {
            background: #B91C1C;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        /* Metrics display */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        
        .metric-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .metric-item .icon {
            font-size: 14px;
        }
        
        .metric-item.happy { color: #10B981; }
        .metric-item.neutral { color: #F59E0B; }
        .metric-item.sad { color: #EF4444; }
        .metric-item.alert { color: #10B981; }
        .metric-item.tired { color: #F59E0B; }
        .metric-item.very-tired { color: #EF4444; }
        .metric-item.excellent { color: #10B981; }
        .metric-item.good { color: #10B981; }
        .metric-item.fair { color: #F59E0B; }
        .metric-item.poor { color: #EF4444; }
        
        /* Analysis items */
        .analysis-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #3B82F6;
        }
        
        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .analysis-number {
            font-size: 11px;
            color: #3B82F6;
            font-weight: 500;
        }
        
        .analysis-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .analysis-text {
            font-size: 13px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .analysis-meta {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 6px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        /* Progress indicator */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: #3B82F6;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .analysis-progress {
            height: 100%;
            background: linear-gradient(90deg, #10B981, #3B82F6);
            border-radius: 2px;
            transition: width 0.1s ease;
            width: 0%;
            position: relative;
        }
        
        .analysis-progress::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        

        

        

        
        /* Responsive design */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .side-panel {
                width: 100%;
                height: 40vh;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            #videoContainer {
                height: 60vh;
            }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Screen States */
        .screen-state {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            transition: all 0.3s ease;
        }
        
        .screen-state.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Idle State */
        .idle-state {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .start-practice-btn {
            background: #3B82F6;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 20px 40px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
        }
        
        .start-practice-btn:hover {
            background: #2563EB;
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.4);
        }
        
        .idle-subtitle {
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-top: 16px;
            text-align: center;
            max-width: 400px;
        }
        
        /* Countdown State */
        .countdown-state {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
        }
        
        .countdown-number {
            font-size: 120px;
            font-weight: 700;
            color: white;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: countdownPulse 1s ease-out;
        }
        
        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .countdown-tip {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            text-align: center;
        }
        
        /* Recording State */
        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 16px;
            height: 16px;
            background: #DC2626;
            border-radius: 50%;
            animation: recordingPulse 2s infinite;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        @keyframes recordingPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }
        
        .stop-btn {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: #DC2626;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 8px 24px rgba(220, 38, 38, 0.3);
        }
        
        .stop-btn:hover {
            background: #B91C1C;
            transform: translateX(-50%) translateY(-2px);
        }
        
        /* Feedback Cards */
        .feedback-container {
            position: absolute;
            bottom: 120px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .feedback-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            font-weight: 500;
            color: #1F2937;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            transform: translateX(-100%);
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: auto;
            max-width: 300px;
        }
        
        .feedback-card.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .feedback-card.fade-out {
            transform: translateX(0) translateY(-20px);
            opacity: 0;
        }
        
        .feedback-icon {
            font-size: 18px;
            flex-shrink: 0;
        }
        
        .feedback-text {
            flex: 1;
        }
        
        /* Edge Lighting */
        .edge-lighting {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-radius: 12px;
            transition: border-color 0.3s ease;
            pointer-events: none;
            z-index: 1;
        }
        
        .edge-lighting.green { border-color: #10B981; }
        .edge-lighting.yellow { border-color: #F59E0B; }
        .edge-lighting.red { border-color: #EF4444; }
        
        /* Progress Timer */
        .progress-timer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            z-index: 10;
        }
        
        .timer-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 3px solid #3B82F6;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: #1F2937;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .timer-circle::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: conic-gradient(var(--progress-color, #3B82F6 0deg, transparent 0deg));
            z-index: -1;
            transition: background 0.3s ease;
        }
        
        /* Paused State */
        .paused-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }
        
        .paused-content {
            text-align: center;
            color: white;
        }
        
        .paused-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        
        .paused-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .btn-resume {
            background: #3B82F6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-resume:hover {
            background: #2563EB;
            transform: translateY(-1px);
        }
        
        .btn-end {
            background: transparent;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-end:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Session Summary */
        .summary-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 20;
            overflow-y: auto;
            padding: 20px 0;
        }
        
        .summary-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            color: #1F2937;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .summary-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 24px;
            color: #10B981;
        }
        
        .score-rings {
            display: flex;
            justify-content: space-around;
            margin: 32px 0;
        }
        
        .score-ring {
            text-align: center;
        }
        
        .score-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
        }
        
        .score-circle.voice { background: #3B82F6; }
        .score-circle.body { background: #10B981; }
        .score-circle.energy { background: #F59E0B; }
        
        .score-label {
            font-size: 12px;
            font-weight: 500;
            color: #6B7280;
        }
        
        /* Typography */
        .text-xl {
            font-size: 18px;
            font-weight: 600;
        }
        
        .text-m {
            font-size: 16px;
            font-weight: 500;
        }
        
        .text-s {
            font-size: 14px;
            font-weight: 400;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Video container -->
        <div id="videoContainer">
            <video id="video" autoplay muted playsinline></video>
            <canvas id="canvas"></canvas>
            
            <!-- Edge Lighting -->
            <div class="edge-lighting" id="edgeLighting"></div>
            
            <!-- Progress Timer -->
            <div class="progress-timer" id="progressTimer" style="display: none;">
                <div class="timer-circle" id="timerCircle">
                    <span id="timerText">0:00</span>
                </div>
            </div>
            
            <!-- Recording Indicator -->
            <div class="recording-indicator" id="recordingIndicator" style="display: none;"></div>
            
            <!-- Stop Button -->
            <button class="stop-btn" id="stopBtn" style="display: none;">⏹ Stop Practice</button>
            
            <!-- Feedback Container -->
            <div class="feedback-container" id="feedbackContainer"></div>
            

            
            <!-- Screen States -->
            <div class="screen-state idle-state" id="idleState">
                <div style="text-align: center;">
                    <button class="start-practice-btn" id="startPracticeBtn">🎤 Start Practice</button>
                    <div class="idle-subtitle">We'll analyze posture, voice & energy in real-time</div>
                </div>
            </div>
            
            <div class="screen-state countdown-state hidden" id="countdownState">
                <div class="countdown-number" id="countdownNumber">3</div>
                <div class="countdown-tip">Sit up straight, smile</div>
        </div>
        
            <div class="screen-state recording-state hidden" id="recordingState">
                <div class="recording-indicator"></div>
                <div class="stop-btn" onclick="stopRecording()">Stop Recording</div>
                </div>

            <div class="screen-state paused-overlay hidden" id="pausedOverlay">
                <div class="paused-content">
                    <div class="paused-title">Practice Paused</div>
                    <div class="paused-buttons">
                        <button class="btn-resume" id="resumeBtn">▶ Resume</button>
                        <button class="btn-end" id="endSessionBtn">End Session</button>
                    </div>
                </div>
            </div>
            
            <div class="screen-state summary-overlay hidden" id="summaryOverlay">
                <div class="summary-card">
                    <div class="summary-title">🎉 Great Practice Session!</div>
                    <div class="score-rings">
                        <div class="score-ring">
                            <div class="score-circle voice" id="voiceScore">85%</div>
                            <div class="score-label">Voice</div>
                        </div>
                        <div class="score-ring">
                            <div class="score-circle body" id="bodyScore">92%</div>
                            <div class="score-label">Body</div>
                    </div>
                        <div class="score-ring">
                            <div class="score-circle energy" id="energyScore">78%</div>
                            <div class="score-label">Energy</div>
                </div>
            </div>
                    <div class="text-m" style="margin-top: 24px;">
                        Keep practicing to improve your presentation skills!
                    </div>
                    <button class="btn btn-primary" id="newSessionBtn" style="margin-top: 24px;">Start New Session</button>
                </div>
            </div>
        </div>
        
        <!-- Side panel -->
        <div class="side-panel">
            <!-- Status -->
            <div class="status-badge" id="status">
                <span class="dot"></span>
                <span id="statusText">Offline</span>
            </div>
            
            <!-- Live Transcription -->
            <div class="card">
                <div class="card-title">
                    🎤 Live Transcription
                </div>
                <div class="card-content">
                    <div id="currentTranscription">
                        <div id="transcriptionText">Click "Start Practice" and speak...</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                        <div class="analysis-progress" id="analysisProgress" style="display: none;"></div>
                    </div>

                </div>
            </div>
            
            <!-- Speech Analysis -->
            <div class="card">
                <div class="card-title">💬 Speech Analysis</div>
                <div class="card-content">
                    <div id="analysisContent">Analysis will appear every 10 seconds...</div>
                </div>
            </div>
            
            <!-- Body Language -->
            <div class="card">
                <div class="card-title">👤 Body Language</div>
                <div class="card-content">
                    <div class="metrics-grid">
                        <div class="metric-item" id="emotionMetric">
                            <span class="icon">😐</span>
                            <span>Neutral</span>
                        </div>
                        <div class="metric-item" id="postureMetric">
                            <span class="icon">📏</span>
                            <span>Good</span>
                        </div>
                        <div class="metric-item" id="fatigueMetric">
                            <span class="icon">⚡</span>
                            <span>Alert</span>
                        </div>
                    </div>
                    <div id="bodyLanguageFeedback" style="margin-top: 12px; font-size: 13px; color: rgba(255, 255, 255, 0.8);">
                        Body language feedback will appear here...
                    </div>
                </div>
            </div>
            
            
        </div>
    </div>

    <!-- State-of-the-art emotion detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script>
        console.log('MediaPipe Face Mesh loaded for accurate emotion detection');
    </script>
    <script src="body_language.js"></script>

    <script>
        let ws = null;
        let recognition = null;
        let isRecording = false;
        let isCameraActive = false;
        let sessionStartTime = 0;
        let sessionDuration = 0;
        let isPaused = false;
        let feedbackQueue = [];
        let performanceScore = 0;
        let analysisTimer = null;
        let analysisProgressValue = 0;
        const clientId = Math.floor(Math.random() * 1000);
        let bodyLanguageInterval = null;
        
        // Score calculation variables
        let speechMetrics = {
            total_words: 0,
            total_fillers: 0,
            analyses_count: 0
        };
        let bodyLanguageHistory = [];
        let emotionHistory = [];
        
        // Feedback cooldown system
        let lastFeedbackTime = 0;
        let feedbackCooldown = 8000; // 8 seconds between feedback
        let lastEmotionFeedback = '';
        let lastPostureFeedback = '';
        let lastFatigueFeedback = '';
        let isSessionActive = false; // Track if session is currently active
        
        // Video recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let sessionVideoBlob = null;
        
        // DOM elements
        const status = document.getElementById('status');
        const statusText = document.getElementById('statusText');
        const transcriptionText = document.getElementById('transcriptionText');
        const analysisContent = document.getElementById('analysisContent');
        const progressFill = document.getElementById('progressFill');
        const analysisProgress = document.getElementById('analysisProgress');
        const bodyLanguageFeedback = document.getElementById('bodyLanguageFeedback');
        const emotionMetric = document.getElementById('emotionMetric');
        const postureMetric = document.getElementById('postureMetric');
        const fatigueMetric = document.getElementById('fatigueMetric');
        
        // Screen state elements
        const idleState = document.getElementById('idleState');
        const countdownState = document.getElementById('countdownState');
        const countdownNumber = document.getElementById('countdownNumber');
        const startPracticeBtn = document.getElementById('startPracticeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const progressTimer = document.getElementById('progressTimer');
        const timerCircle = document.getElementById('timerCircle');
        const timerText = document.getElementById('timerText');
        const pausedOverlay = document.getElementById('pausedOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const endSessionBtn = document.getElementById('endSessionBtn');
        const summaryOverlay = document.getElementById('summaryOverlay');
        const newSessionBtn = document.getElementById('newSessionBtn');
        const feedbackContainer = document.getElementById('feedbackContainer');
        const edgeLighting = document.getElementById('edgeLighting');

        // Check if browser supports speech recognition
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        
        if (!SpeechRecognition) {
            alert('Your browser does not support speech recognition. Please use Chrome, Edge, or Safari.');
        }

        // Screen State Management
        function showState(stateElement) {
            // Hide all states
            document.querySelectorAll('.screen-state, .paused-overlay, .summary-overlay').forEach(el => {
                el.classList.add('hidden');
            });
            // Show target state
            stateElement.classList.remove('hidden');
        }

        async function startPractice() {
            // Auto-connect to server if not connected
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                await connect();
            }
            
            showState(countdownState);
            startCountdown();
        }

        function startCountdown() {
            let count = 3;
            countdownNumber.textContent = count;
            
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                    countdownNumber.style.animation = 'none';
                    setTimeout(() => {
                        countdownNumber.style.animation = 'countdownPulse 1s ease-out';
                    }, 10);
                } else {
                    clearInterval(countdownInterval);
                    startRecordingSession();
                }
            }, 1000);
        }

        async function startRecordingSession() {
            sessionStartTime = Date.now();
            sessionDuration = 0;
            performanceScore = 0;
            isSessionActive = true; // Mark session as active
            
            // Reset score calculation variables for new session
            speechMetrics = {
                total_words: 0,
                total_fillers: 0,
                analyses_count: 0
            };
            bodyLanguageHistory = [];
            emotionHistory = [];
            
            // Reset feedback cooldown variables for new session
            lastFeedbackTime = 0;
            lastEmotionFeedback = '';
            lastPostureFeedback = '';
            lastFatigueFeedback = '';
            
            // Reset score display to neutral
            document.getElementById('voiceScore').textContent = '50%';
            document.getElementById('bodyScore').textContent = '50%';
            document.getElementById('energyScore').textContent = '50%';
            
            // Hide all screen states to show the video with overlay elements
            document.querySelectorAll('.screen-state, .paused-overlay, .summary-overlay').forEach(el => {
                el.classList.add('hidden');
            });
            
            // Show recording elements
            recordingIndicator.style.display = 'block';
            stopBtn.style.display = 'block';
            progressTimer.style.display = 'block';
            
            // Automatically start camera and body language analysis
            if (!isCameraActive) {
                try {
                    const success = await window.bodyLanguage.start();
                    if (success) {
                        // Set WebSocket reference for body language module
                        if (ws) {
                            window.bodyLanguage.setWebSocket(ws);
                        }
                        isCameraActive = true;
                        
                        // Start body language interval
                        if (bodyLanguageInterval) {
                            clearInterval(bodyLanguageInterval);
                        }
                        bodyLanguageInterval = setInterval(() => {
                            if (window.bodyLanguage && window.bodyLanguage.sendBodyLanguageData) {
                                window.bodyLanguage.sendBodyLanguageData();
                            }
                        }, 2000);
                        
                        // Start video recording
                        await startVideoRecording();
                    }
                } catch (error) {
                    console.error('Camera error:', error.message);
                }
            }
            
            // Start recording immediately
            startRecording();
            
            // Start session timer
            const sessionTimer = setInterval(() => {
                if (!isPaused) {
                    sessionDuration++;
                    updateSessionTimer();
                    updateEdgeLighting();
                }
            }, 1000);
            
            // Store timer reference
            window.sessionTimer = sessionTimer;
        }

        function updateSessionTimer() {
            const minutes = Math.floor(sessionDuration / 60);
            const seconds = sessionDuration % 60;
            timerText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Update circular progress (assuming 5 minute session)
            const progress = (sessionDuration / 300) * 360;
            timerCircle.style.setProperty('--progress', `${progress}deg`);
            timerCircle.style.setProperty('--progress-color', `#3B82F6 ${progress}deg, transparent ${progress}deg`);
        }

        function updateEdgeLighting() {
            // Calculate performance score based on recent feedback
            const recentFeedback = feedbackQueue.slice(-5);
            const positiveCount = recentFeedback.filter(f => f.type === 'positive').length;
            const negativeCount = recentFeedback.filter(f => f.type === 'negative').length;
            
            if (positiveCount > negativeCount) {
                edgeLighting.className = 'edge-lighting green';
            } else if (negativeCount > positiveCount) {
                edgeLighting.className = 'edge-lighting red';
            } else {
                edgeLighting.className = 'edge-lighting yellow';
            }
        }

        function pauseSession() {
            isPaused = true;
            showState(pausedOverlay);
            if (recognition && isRecording) {
                recognition.stop();
            }
        }

        function resumeSession() {
            isPaused = false;
            // Hide all screen states to show the video with overlay elements
            document.querySelectorAll('.screen-state, .paused-overlay, .summary-overlay').forEach(el => {
                el.classList.add('hidden');
            });
            startRecording();
        }

        function endSession() {
            // Stop recording
            if (recognition && isRecording) {
                isRecording = false;
                recognition.stop();
            }
            
            // Stop video recording
            stopVideoRecording();
            
            // Stop body language analysis
            if (bodyLanguageInterval) {
                clearInterval(bodyLanguageInterval);
                bodyLanguageInterval = null;
            }
            
            // Stop body language module
            if (window.bodyLanguage && window.bodyLanguage.stop) {
                window.bodyLanguage.stop();
            }
            
            // Clear timers
            if (window.sessionTimer) {
                clearInterval(window.sessionTimer);
            }
            
            // Mark session as inactive
            isSessionActive = false;
            
            // Calculate final scores (this will be the last update)
            calculateSessionScores();
            
            // Show summary
            showState(summaryOverlay);
        }

        function calculateSessionScores() {
            // Only calculate scores if session is active
            if (!isSessionActive) {
                return;
            }
            
            // Calculate realistic scores based on actual metrics and feedback
            let voiceScore = 50; // Start with neutral base
            let bodyScore = 50;
            let energyScore = 50;
            
            // Voice score factors
            const totalWords = speechMetrics.total_words || 0;
            const totalFillers = speechMetrics.total_fillers || 0;
            const analysesCount = speechMetrics.analyses_count || 0;
            
            // Voice score calculation
            if (totalWords > 0) {
                // Clarity factor (fewer fillers = better)
                const fillerRatio = totalFillers / totalWords;
                const clarityBonus = Math.max(0, 30 - (fillerRatio * 100));
                
                // Engagement factor (more words = better engagement)
                const engagementBonus = Math.min(20, totalWords / 10);
                
                // Consistency factor (more analyses = more consistent)
                const consistencyBonus = Math.min(10, analysesCount * 2);
                
                voiceScore = 40 + clarityBonus + engagementBonus + consistencyBonus;
            }
            
            // Body score factors
            const bodyAnalyses = bodyLanguageHistory.length || 0;
            const recentEmotions = emotionHistory.slice(-5); // Last 5 emotions
            
            if (recentEmotions.length > 0) {
                // Posture and presence factor
                const goodPostureCount = recentEmotions.filter(e => e.posture === 'good').length;
                const postureBonus = (goodPostureCount / recentEmotions.length) * 25;
                
                // Emotional engagement factor
                const positiveEmotions = recentEmotions.filter(e => 
                    e.emotion === 'happy' || e.emotion === 'engaged'
                ).length;
                const emotionBonus = (positiveEmotions / recentEmotions.length) * 15;
                
                // Consistency factor
                const consistencyBonus = Math.min(10, bodyAnalyses * 2);
                
                bodyScore = 35 + postureBonus + emotionBonus + consistencyBonus;
            }
            
            // Energy score factors
            const fatigueLevels = recentEmotions.filter(e => e.fatigue).map(e => e.fatigue);
            const alertCount = fatigueLevels.filter(f => f === 'alert').length;
            
            if (fatigueLevels.length > 0) {
                // Alertness factor
                const alertnessBonus = (alertCount / fatigueLevels.length) * 30;
                
                // Session engagement factor
                const sessionEngagement = Math.min(15, sessionDuration / 10);
                
                // Performance factor
                const performanceBonus = Math.min(10, Math.max(-10, performanceScore * 2));
                
                energyScore = 40 + alertnessBonus + sessionEngagement + performanceBonus;
            }
            
            // Apply realistic bounds and round
            voiceScore = Math.min(95, Math.max(25, Math.round(voiceScore)));
            bodyScore = Math.min(95, Math.max(25, Math.round(bodyScore)));
            energyScore = Math.min(95, Math.max(25, Math.round(energyScore)));
            
            document.getElementById('voiceScore').textContent = `${voiceScore}%`;
            document.getElementById('bodyScore').textContent = `${bodyScore}%`;
            document.getElementById('energyScore').textContent = `${energyScore}%`;
        }

        function resetSession() {
            // Reset all states
            showState(idleState);
            recordingIndicator.style.display = 'none';
            stopBtn.style.display = 'none';
            progressTimer.style.display = 'none';
            edgeLighting.className = 'edge-lighting';
            
            // Reset analysis timer
            resetAnalysisTimer();
            
            // Stop camera if active
            if (isCameraActive) {
                const videoElement = document.getElementById('video');
                const stream = videoElement ? videoElement.srcObject : null;
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    videoElement.srcObject = null;
                }
                isCameraActive = false;
            }
            
            // Clear body language interval
            if (bodyLanguageInterval) {
                clearInterval(bodyLanguageInterval);
                bodyLanguageInterval = null;
            }
            
            // Clear feedback
            feedbackContainer.innerHTML = '';
            feedbackQueue = [];
            
            // Reset variables
            isRecording = false;
            isPaused = false;
            sessionDuration = 0;
            performanceScore = 0;
            isSessionActive = false; // Mark session as inactive
            
            // Reset score calculation variables
            speechMetrics = {
                total_words: 0,
                total_fillers: 0,
                analyses_count: 0
            };
            bodyLanguageHistory = [];
            emotionHistory = [];
            
            // Reset feedback cooldown variables
            lastFeedbackTime = 0;
            lastEmotionFeedback = '';
            lastPostureFeedback = '';
            lastFatigueFeedback = '';
            
            // Reset score display
            document.getElementById('voiceScore').textContent = '50%';
            document.getElementById('bodyScore').textContent = '50%';
            document.getElementById('energyScore').textContent = '50%';
        }

        // Feedback System
        function showFeedback(message, type = 'info', duration = 6000) {
            const now = Date.now();
            
            // Check cooldown - don't show feedback too frequently
            if (now - lastFeedbackTime < feedbackCooldown) {
                return;
            }
            
            // Don't repeat the same feedback message
            const recentFeedback = feedbackQueue.slice(-3);
            if (recentFeedback.some(f => f.message === message)) {
                return;
            }
            
            const feedback = {
                message,
                type,
                timestamp: now
            };
            
            feedbackQueue.push(feedback);
            lastFeedbackTime = now;
            
            // Keep only last 8 feedback items (reduced from 10)
            if (feedbackQueue.length > 8) {
                feedbackQueue.shift();
            }
            
            // Create feedback card
            const card = document.createElement('div');
            card.className = 'feedback-card';
            
            const icon = getFeedbackIcon(type);
            card.innerHTML = `
                <div class="feedback-icon">${icon}</div>
                <div class="feedback-text">${message}</div>
            `;
            
            feedbackContainer.appendChild(card);
            
            // Animate in
            setTimeout(() => {
                card.classList.add('show');
            }, 100);
            
            // Auto-dismiss
            setTimeout(() => {
                card.classList.add('fade-out');
                setTimeout(() => {
                    if (card.parentNode) {
                        card.parentNode.removeChild(card);
                    }
                }, 300);
            }, duration);
            
            // Update performance score
            if (type === 'positive') {
                performanceScore += 1;
            } else if (type === 'negative') {
                performanceScore -= 1;
            }
        }

        function getFeedbackIcon(type) {
            const icons = {
                positive: '👍',
                warning: '⚠️',
                negative: '⛔',
                info: '💡'
            };
            return icons[type] || icons.info;
        }





        function connect() {
            return new Promise((resolve, reject) => {
            ws = new WebSocket(`ws://localhost:8000/ws/text/${clientId}`);

            ws.onopen = () => {
                    status.className = 'status-badge connected';
                    statusText.textContent = `Client #${clientId}`;
                    
                    // Start heartbeat to keep connection alive
                    const heartbeat = setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'heartbeat',
                                client_id: clientId,
                                timestamp: new Date().toISOString()
                            }));
                        } else {
                            clearInterval(heartbeat);
                        }
                    }, 30000); // Send heartbeat every 30 seconds
                    
                    resolve();
            };

            ws.onmessage = (event) => {
                console.log('WebSocket message received:', event.data);
                try {
                const data = JSON.parse(event.data);
                    console.log('Parsed message data:', data);
                    
                if (data.type === 'response') {
                    // Don't show character count messages
                        console.log('Response message ignored');
                } else if (data.type === 'analysis') {
                        console.log('Speech analysis received:', data);
                    displayAnalysis(data);
                } else if (data.type === 'body_language_feedback') {
                        console.log('Body language feedback received:', data);
                    displayBodyLanguageFeedback(data);
                    } else {
                        console.log('Unknown message type:', data.type, data);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error, event.data);
                }
            };

            ws.onerror = (error) => {
                    reject(error);
            };

            ws.onclose = () => {
                    status.className = 'status-badge';
                    statusText.textContent = 'Offline';
                ws = null;
            };
            });
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        // Event Listeners
        startPracticeBtn.onclick = startPractice;
        stopBtn.onclick = pauseSession;
        resumeBtn.onclick = resumeSession;
        endSessionBtn.onclick = endSession;
        newSessionBtn.onclick = resetSession;







        // Listen for body language data updates to update UI
        window.addEventListener('bodyLanguageUpdate', (event) => {
            const { emotion, posture, fatigue } = event.detail;
            updateBodyLanguageMetrics(emotion, posture, fatigue);
        });

        // Enable body language analysis on load
        window.addEventListener('load', () => {
            console.log('Face detection ready - will start automatically with practice');
        });

        // Update existing functions to integrate with feedback system
        function displayAnalysis(data) {
            console.log('Displaying analysis:', data.analysis_number, data.text);
            
            // Complete the loading bar when analysis arrives
            if (analysisTimer) {
                clearInterval(analysisTimer);
                analysisTimer = null;
            }
            analysisProgress.style.display = 'none';
            progressFill.style.display = 'block';
            analysisProgressValue = 0;
            
            // Clear transcription text and reset for fresh start
            transcriptionText.textContent = 'Listening...';
            transcriptionText.innerHTML = 'Listening...';
            
            // Reset the global transcript for next analysis cycle
            if (window.currentFinalTranscript !== undefined) {
                window.currentFinalTranscript = '';
            }
            
            // Start new timer for next analysis
            startAnalysisTimer();
            
            // Update speech metrics
            const transcript = data.transcript_analyzed || '';
            const words = transcript.split(' ').filter(word => word.trim().length > 0);
            const wordCount = words.length;
            
            // Count filler words
            const fillerWords = ['um', 'uh', 'like', 'you know', 'basically', 'actually', 'literally'];
            const fillerCount = words.filter(word => 
                fillerWords.includes(word.toLowerCase())
            ).length;
            
            speechMetrics.total_words += wordCount;
            speechMetrics.total_fillers += fillerCount;
            speechMetrics.analyses_count += 1;
            
            const analysisDiv = document.createElement('div');
            analysisDiv.className = 'analysis-item';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'analysis-header';
            
            const numberDiv = document.createElement('div');
            numberDiv.className = 'analysis-number';
            numberDiv.textContent = `Analysis #${data.analysis_number || 1}`;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'analysis-time';
            timeDiv.textContent = new Date(data.timestamp).toLocaleTimeString();
            
            headerDiv.appendChild(numberDiv);
            headerDiv.appendChild(timeDiv);
            
            const textDiv = document.createElement('div');
            textDiv.className = 'analysis-text';
            textDiv.textContent = data.text;
            
            const metaDiv = document.createElement('div');
            metaDiv.className = 'analysis-meta';
            metaDiv.textContent = `${wordCount} words analyzed (${fillerCount} fillers)`;
            
            analysisDiv.appendChild(headerDiv);
            analysisDiv.appendChild(textDiv);
            analysisDiv.appendChild(metaDiv);
            
            // Replace old analysis with new one
            analysisContent.innerHTML = '';
            analysisContent.appendChild(analysisDiv);
            
            // Update scores (only if session is active)
            if (isSessionActive) {
                calculateSessionScores();
            }
            
            // Show feedback based on analysis content (less frequently)
            const analysisText = data.text.toLowerCase();
            const now = Date.now();
            const timeSinceLastFeedback = now - lastFeedbackTime;
            
            // Only show feedback every 12 seconds
            if (timeSinceLastFeedback > 12000) {
                if (analysisText.includes('great') || analysisText.includes('good') || analysisText.includes('improved')) {
                    showFeedback('Great progress! Keep it up!', 'positive', 4000);
                } else if (analysisText.includes('slow') || analysisText.includes('pace')) {
                    showFeedback('Try slowing your pace by ~10%', 'warning', 4000);
                } else if (analysisText.includes('volume') || analysisText.includes('speak')) {
                    showFeedback('Speak a bit louder', 'warning', 4000);
                } else if (analysisText.includes('filler') || analysisText.includes('um')) {
                    showFeedback('Try reducing filler words', 'warning', 4000);
                }
            }
        }

        function displayBodyLanguageFeedback(data) {
            bodyLanguageFeedback.textContent = data.text;
            
            // Store body language feedback in history
            bodyLanguageHistory.push({
                text: data.text,
                timestamp: data.timestamp,
                analysis_number: data.analysis_number
            });
            
            // Keep only last 10 body language analyses
            if (bodyLanguageHistory.length > 10) {
                bodyLanguageHistory.shift();
            }
            
            // Update scores (only if session is active)
            if (isSessionActive) {
                calculateSessionScores();
            }
            
            // Show feedback based on body language (less frequently)
            const feedbackText = data.text.toLowerCase();
            const now = Date.now();
            const timeSinceLastFeedback = now - lastFeedbackTime;
            
            // Only show feedback every 15 seconds
            if (timeSinceLastFeedback > 15000) {
                if (feedbackText.includes('good') || feedbackText.includes('excellent') || feedbackText.includes('great')) {
                    showFeedback('Excellent body language!', 'positive', 4000);
                } else if (feedbackText.includes('posture') || feedbackText.includes('straight')) {
                    showFeedback('Sit up straight for better presence', 'warning', 4000);
                } else if (feedbackText.includes('eye contact')) {
                    showFeedback('Hold eye contact with the camera', 'warning', 4000);
                } else if (feedbackText.includes('energy') || feedbackText.includes('tired')) {
                    showFeedback('Try to show more energy', 'warning', 4000);
                }
            }
        }

        function updateBodyLanguageMetrics(emotion, posture, fatigue) {
            // Update emotion metric with emoji and color
            const emotionIcon = getEmotionIcon(emotion);
            const emotionClass = getEmotionClass(emotion);
            emotionMetric.innerHTML = `<span class="icon">${emotionIcon}</span><span>${emotion}</span>`;
            emotionMetric.className = `metric-item ${emotionClass}`;

            // Update posture metric
            const postureIcon = '📏';
            const postureClass = getPostureClass(posture.label);
            postureMetric.innerHTML = `<span class="icon">${postureIcon}</span><span>${posture.label}</span>`;
            postureMetric.className = `metric-item ${postureClass}`;

            // Update fatigue metric
            const fatigueIcon = '⚡';
            const fatigueClass = getFatigueClass(fatigue.label);
            fatigueMetric.innerHTML = `<span class="icon">${fatigueIcon}</span><span>${fatigue.label}</span>`;
            fatigueMetric.className = `metric-item ${fatigueClass}`;
            
            // Store emotion data in history
            emotionHistory.push({
                emotion: emotion,
                posture: posture.label,
                fatigue: fatigue.label,
                timestamp: Date.now()
            });
            
            // Keep only last 20 emotion data points
            if (emotionHistory.length > 20) {
                emotionHistory.shift();
            }
            
            // Update scores periodically (every 10 emotion updates instead of 5) - only if session is active
            if (emotionHistory.length % 10 === 0 && isSessionActive) {
                calculateSessionScores();
            }
            
            // Show feedback only occasionally and for significant changes
            const now = Date.now();
            const timeSinceLastFeedback = now - lastFeedbackTime;
            
            // Only show feedback every 15 seconds and for notable changes
            if (timeSinceLastFeedback > 15000) {
                if (emotion === 'happy' && lastEmotionFeedback !== 'happy') {
                    showFeedback('Great energy! Keep smiling!', 'positive', 3000);
                    lastEmotionFeedback = 'happy';
                } else if (posture.label === 'poor' && lastPostureFeedback !== 'poor') {
                    showFeedback('Adjust your posture', 'warning', 3000);
                    lastPostureFeedback = 'poor';
                } else if (fatigue.label === 'tired' && lastFatigueFeedback !== 'tired') {
                    showFeedback('Show more enthusiasm', 'warning', 3000);
                    lastFatigueFeedback = 'tired';
                }
            }
        }
        
        // Make function available globally for body language module
        window.updateBodyLanguageMetrics = updateBodyLanguageMetrics;

        function getEmotionIcon(emotion) {
            const icons = {
                'happy': '😄',
                'sad': '😞',
                'angry': '😠',
                'surprised': '😲',
                'fearful': '😨',
                'disgusted': '🤢',
                'neutral': '😐'
            };
            return icons[emotion] || '😐';
        }

        function getEmotionClass(emotion) {
            if (['happy', 'surprised'].includes(emotion)) return 'happy';
            if (['sad', 'angry', 'fearful', 'disgusted'].includes(emotion)) return 'sad';
            return 'neutral';
        }

        function getPostureClass(posture) {
            if (['excellent', 'good'].includes(posture)) return 'good';
            if (posture === 'poor') return 'poor';
            return 'fair';
        }

        function getFatigueClass(fatigue) {
            if (fatigue === 'alert') return 'alert';
            if (fatigue === 'tired') return 'tired';
            if (fatigue === 'very tired') return 'very-tired';
            return 'alert';
        }



        function startAnalysisTimer() {
            analysisProgressValue = 0;
            analysisProgress.style.display = 'block';
            progressFill.style.display = 'none';
            
            analysisTimer = setInterval(() => {
                analysisProgressValue += 1;
                analysisProgress.style.width = `${analysisProgressValue}%`;
                
                // Don't complete the bar - wait for actual analysis
                if (analysisProgressValue >= 100) {
                    analysisProgressValue = 100;
                    analysisProgress.style.width = '100%';
                    console.log('Analysis timer completed - waiting for backend analysis...');
                }
            }, 100); // 10 seconds total (100 * 100ms)
        }
        
        function resetAnalysisTimer() {
            if (analysisTimer) {
                clearInterval(analysisTimer);
                analysisTimer = null;
            }
            analysisProgressValue = 0;
            analysisProgress.style.display = 'none';
            progressFill.style.display = 'block';
        }

        function startRecording() {
            if (!SpeechRecognition) {
                console.error('Speech recognition not supported');
                return;
            }

            console.log('Starting speech recognition...');
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            let finalTranscript = '';
            let lastSentIndex = 0;
            
            // Make finalTranscript accessible to displayAnalysis function
            window.currentFinalTranscript = finalTranscript;

            recognition.onstart = () => {
                console.log('Speech recognition started');
                isRecording = true;
                transcriptionText.textContent = 'Listening...';
                startAnalysisTimer();
            };

            recognition.onresult = (event) => {
                console.log('Speech recognition result:', event.results.length, 'results');
                let interimTranscript = '';
                let currentTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    console.log(`Result ${i}: "${transcript}" (final: ${event.results[i].isFinal})`);
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                        currentTranscript = finalTranscript;
                        window.currentFinalTranscript = finalTranscript;
                    } else {
                        interimTranscript += transcript;
                        currentTranscript = finalTranscript + interimTranscript;
                    }
                }
                
                // Stream ALL text (final + interim) to backend continuously
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const message = {
                        type: 'streaming_transcription',
                        text: currentTranscript.trim(),
                        is_final: interimTranscript === '',
                        client_id: clientId,
                        timestamp: new Date().toISOString()
                    };
                    console.log('Sending transcription to server:', message);
                    ws.send(JSON.stringify(message));
                } else {
                    console.log('WebSocket not ready. State:', ws ? ws.readyState : 'null');
                }
                
                // Update the display with both final and interim results
                transcriptionText.innerHTML = 
                    finalTranscript + 
                    '<span class="highlight">' + interimTranscript + '</span>';
                
                // Auto-scroll to bottom
                const transcriptionContainer = document.getElementById('currentTranscription');
                transcriptionContainer.scrollTop = transcriptionContainer.scrollHeight;
            };

            recognition.onerror = (event) => {
                if (event.error === 'no-speech') {
                    transcriptionText.textContent = 'No speech detected. Please try again.';
                }
            };

            recognition.onend = () => {
                console.log('Speech recognition ended');
                
                // Send any remaining text
                const remainingText = finalTranscript.substring(lastSentIndex);
                if (remainingText.trim() && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'final_transcription',
                        text: remainingText.trim(),
                        client_id: clientId,
                        timestamp: new Date().toISOString()
                    }));
                }

                // Restart recognition if still in recording state
                if (isRecording && !isPaused) {
                    console.log('Restarting speech recognition...');
                    setTimeout(() => {
                        try {
            recognition.start();
                        } catch (error) {
                            console.error('Failed to restart recognition:', error);
                        }
                    }, 100);
            } else {
                    isRecording = false;
                    progressFill.style.width = '0%';
                }
            };

            recognition.start();
        }

        function stopRecording() {
            if (recognition && isRecording) {
                recognition.stop();
            }
        }

        // Video Recording Functions
        async function startVideoRecording() {
            const videoElement = document.getElementById('video');
            let stream = videoElement.srcObject;
            
            if (!stream) {
                console.error('No video stream available');
                return;
            }
            
            // Get audio stream to combine with video
            try {
                const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioTracks = audioStream.getAudioTracks();
                
                // Create a new stream combining video and audio
                const combinedStream = new MediaStream();
                
                // Add video tracks from existing stream
                stream.getVideoTracks().forEach(track => {
                    combinedStream.addTrack(track);
                });
                
                // Add audio tracks
                audioTracks.forEach(track => {
                    combinedStream.addTrack(track);
                });
                
                stream = combinedStream;
                console.log('Combined video and audio streams for recording');
            } catch (error) {
                console.error('Error getting audio stream:', error);
                console.log('Recording video only without audio');
            }
            
            // Clear previous recording
            recordedChunks = [];
            
            // Create MediaRecorder with video and audio
            const options = {
                mimeType: 'video/webm;codecs=vp9,opus'
            };
            
            // Check if the browser supports the mimeType
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/mp4';
                }
            }
            
            try {
                mediaRecorder = new MediaRecorder(stream, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    console.log('Video recording stopped, creating blob...');
                    sessionVideoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    console.log('Video blob created, size:', sessionVideoBlob.size);
                    
                    // Display video preview instead of auto-sending
                    displayVideoPreview();
                };
                
                mediaRecorder.start(1000); // Collect data every second
                console.log('Video recording started');
            } catch (error) {
                console.error('MediaRecorder error:', error);
            }
        }
        
        function stopVideoRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                console.log('Stopping video recording...');
                
                // Stop all tracks in the media recorder stream
                if (mediaRecorder.stream) {
                    mediaRecorder.stream.getTracks().forEach(track => {
                        if (track.label.includes('Audio') || track.kind === 'audio') {
                            track.stop();
                            console.log('Stopped audio track:', track.label);
                        }
                    });
                }
            }
        }
        
        function displayVideoPreview() {
            const summaryCard = document.querySelector('.summary-card');
            
            // Create video preview section
            const videoSection = document.createElement('div');
            videoSection.style.marginTop = '32px';
            videoSection.style.padding = '24px';
            videoSection.style.background = 'rgba(0, 0, 0, 0.05)';
            videoSection.style.borderRadius = '12px';
            
            // Create video element
            const videoPreview = document.createElement('video');
            videoPreview.style.width = '100%';
            videoPreview.style.maxHeight = '300px';
            videoPreview.style.borderRadius = '8px';
            videoPreview.style.marginBottom = '16px';
            videoPreview.controls = true;
            videoPreview.src = URL.createObjectURL(sessionVideoBlob);
            
            // Create download button
            const downloadBtn = document.createElement('a');
            downloadBtn.className = 'btn btn-secondary';
            downloadBtn.style.marginRight = '12px';
            downloadBtn.href = URL.createObjectURL(sessionVideoBlob);
            downloadBtn.download = `session_${clientId}_${Date.now()}.webm`;
            downloadBtn.innerHTML = '📥 Download Video';
            
            // Create analyze button
            const analyzeBtn = document.createElement('button');
            analyzeBtn.className = 'btn btn-primary';
            analyzeBtn.innerHTML = '🔍 Send for Detailed Analysis';
            
            // Check minimum duration (4 seconds required by TwelveLabs)
            if (sessionDuration < 4) {
                analyzeBtn.disabled = true;
                analyzeBtn.innerHTML = '❌ Session Too Short (Min: 4s)';
                analyzeBtn.title = 'TwelveLabs requires videos to be at least 4 seconds long';
            } else {
                analyzeBtn.onclick = async () => {
                    analyzeBtn.disabled = true;
                    analyzeBtn.innerHTML = '⏳ Analyzing...';
                    await sendVideoForAnalysis();
                    analyzeBtn.style.display = 'none';
                };
            }
            
            videoSection.innerHTML = `
                <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: #1F2937;">
                    📹 Your Practice Session Recording
                </h3>
            `;
            
            videoSection.appendChild(videoPreview);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '12px';
            buttonContainer.style.justifyContent = 'center';
            buttonContainer.appendChild(downloadBtn);
            buttonContainer.appendChild(analyzeBtn);
            
            videoSection.appendChild(buttonContainer);
            
            // Insert after the score rings
            const scoreRings = document.querySelector('.score-rings');
            scoreRings.parentNode.insertBefore(videoSection, scoreRings.nextSibling);
        }
        
        async function sendVideoForAnalysis() {
            if (!sessionVideoBlob) {
                console.error('No video blob available');
                return;
            }
            
            // Show loading state in summary
            const summaryTitle = document.querySelector('.summary-title');
            summaryTitle.innerHTML = '⏳ Analyzing your session with TwelveLabs...';
            
            try {
                // Create FormData with video
                const formData = new FormData();
                formData.append('video', sessionVideoBlob, `session_${clientId}_${Date.now()}.webm`);
                formData.append('client_id', clientId);
                formData.append('duration', sessionDuration);
                
                // Send to backend
                const response = await fetch('/api/analyze-video', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Response status:', response.status);
                const result = await response.json();
                console.log('TwelveLabs analysis result:', result);
                
                if (!response.ok) {
                    console.error('Response error:', result);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Display the analysis results
                displayTwelveLabsAnalysis(result);
                
            } catch (error) {
                console.error('Error sending video for analysis:', error);
                summaryTitle.innerHTML = '🎉 Session Complete!';
                // Add error message
                const summaryCard = document.querySelector('.summary-card');
                const errorMsg = document.createElement('div');
                errorMsg.style.color = '#EF4444';
                errorMsg.style.fontSize = '14px';
                errorMsg.style.marginTop = '16px';
                errorMsg.textContent = 'Video analysis unavailable at this time.';
                summaryCard.insertBefore(errorMsg, summaryCard.children[1]);
            }
        }
        
        function displayTwelveLabsAnalysis(analysis) {
            const summaryCard = document.querySelector('.summary-card');
            
            // Update title
            const summaryTitle = document.querySelector('.summary-title');
            summaryTitle.innerHTML = '🎉 Great Practice Session!';
            
            // Check if there's an error in the analysis
            if (analysis.error) {
                console.error('TwelveLabs error:', analysis.error);
                // Still show what we can
            }
            
            // Create analysis section
            const analysisSection = document.createElement('div');
            analysisSection.style.marginTop = '32px';
            analysisSection.style.padding = '24px';
            analysisSection.style.background = 'rgba(59, 130, 246, 0.1)';
            analysisSection.style.borderRadius = '12px';
            analysisSection.style.textAlign = 'left';
            
            analysisSection.innerHTML = `
                <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: #1F2937;">
                    📹 Video Analysis Report
                </h3>
                <div style="font-size: 14px; line-height: 1.6; color: #374151;">
                    ${formatTwelveLabsAnalysis(analysis)}
                </div>
            `;
            
            // Insert after the score rings
            const scoreRings = document.querySelector('.score-rings');
            scoreRings.parentNode.insertBefore(analysisSection, scoreRings.nextSibling);
        }
        
        function formatTwelveLabsAnalysis(analysis) {
            let html = '';
            
            // Show detailed analysis if available
            if (analysis.detailed_analysis) {
                html += `<div style="margin-bottom: 20px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                    <strong style="font-size: 16px; display: block; margin-bottom: 12px;">🔍 Comprehensive Therapy Analysis</strong>
                    <div style="white-space: pre-line; line-height: 1.6;">
                        ${analysis.detailed_analysis}
                    </div>
                </div>`;
            } else if (analysis.summary) {
                html += `<div style="margin-bottom: 16px;">
                    <strong>Session Summary:</strong><br>
                    ${analysis.summary}
                </div>`;
            }
            
            if (analysis.key_moments && analysis.key_moments.length > 0) {
                html += `<div style="margin-bottom: 16px;">
                    <strong>Key Moments:</strong><br>
                    <ul style="margin: 8px 0; padding-left: 20px;">`;
                analysis.key_moments.forEach(moment => {
                    html += `<li>${moment}</li>`;
                });
                html += `</ul></div>`;
            }
            
            if (analysis.recommendations && analysis.recommendations.length > 0 && !analysis.detailed_analysis) {
                html += `<div style="margin-bottom: 16px;">
                    <strong>Recommendations:</strong><br>
                    <ul style="margin: 8px 0; padding-left: 20px;">`;
                analysis.recommendations.forEach(rec => {
                    html += `<li>${rec}</li>`;
                });
                html += `</ul></div>`;
            }
            
            if (analysis.topics && analysis.topics.length > 0) {
                html += `<div style="margin-bottom: 16px;">
                    <strong>Topics Covered:</strong> ${analysis.topics.join(', ')}
                </div>`;
            }
            
            if (analysis.note) {
                html += `<div style="margin-top: 16px; padding: 12px; background: rgba(251, 191, 36, 0.1); border-radius: 8px; font-size: 13px;">
                    <strong>Note:</strong> ${analysis.note}
                </div>`;
            }
            
            // Show session duration
            html += `<div style="margin-top: 16px; font-size: 13px; color: #6B7280;">
                Session Duration: ${Math.floor(sessionDuration / 60)}:${(sessionDuration % 60).toString().padStart(2, '0')}
            </div>`;
            
            return html || 'Analysis complete. Your session has been processed successfully.';
        }
    </script>
</body>
</html>
