<!DOCTYPE html>
<html>
<head>
    <title>Live Speech Recognition Client</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background: #000;
        }
        
        /* Main layout */
        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        /* Video container - full bleed */
        #videoContainer {
            flex: 1;
            position: relative;
            background: #000;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        /* Side panel */
        .side-panel {
            width: 320px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            padding: 16px;
            gap: 16px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        /* Status badge */
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 500;
            color: white;
            background: #DC2626;
            transition: all 0.2s ease;
        }
        
        .status-badge.connected {
            background: #059669;
        }
        
        .status-badge .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }
        
        /* Card style */
        .card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.2s ease;
        }
        
        .card:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        /* Typography */
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            margin: 0 0 12px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .card-content {
            font-size: 14px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }
        
        /* Transcription area */
        #currentTranscription { 
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            min-height: 60px; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
            overflow-y: auto;
            max-height: 120px;
        }
        
        .highlight { 
            background-color: rgba(59, 130, 246, 0.3);
            padding: 1px 2px;
            border-radius: 2px;
        }
        

        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: #3B82F6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563EB;
            transform: translateY(-1px);
        }
        
        .btn-primary.recording {
            background: #DC2626;
            animation: pulse 2s infinite;
        }
        
        .btn-primary.recording:hover {
            background: #B91C1C;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        /* Metrics display */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        
        .metric-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .metric-item .icon {
            font-size: 14px;
        }
        
        .metric-item.happy { color: #10B981; }
        .metric-item.neutral { color: #F59E0B; }
        .metric-item.sad { color: #EF4444; }
        .metric-item.alert { color: #10B981; }
        .metric-item.tired { color: #F59E0B; }
        .metric-item.very-tired { color: #EF4444; }
        .metric-item.excellent { color: #10B981; }
        .metric-item.good { color: #10B981; }
        .metric-item.fair { color: #F59E0B; }
        .metric-item.poor { color: #EF4444; }
        
        /* Analysis items */
        .analysis-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #3B82F6;
        }
        
        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .analysis-number {
            font-size: 11px;
            color: #3B82F6;
            font-weight: 500;
        }
        
        .analysis-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .analysis-text {
            font-size: 13px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .analysis-meta {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 6px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        /* Progress indicator */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: #3B82F6;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .analysis-progress {
            height: 100%;
            background: linear-gradient(90deg, #10B981, #3B82F6);
            border-radius: 2px;
            transition: width 0.1s ease;
            width: 0%;
            position: relative;
        }
        
        .analysis-progress::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        

        

        

        
        /* Responsive design */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .side-panel {
                width: 100%;
                height: 40vh;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            #videoContainer {
                height: 60vh;
            }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Screen States */
        .screen-state {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            transition: all 0.3s ease;
        }
        
        .screen-state.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Idle State */
        .idle-state {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .start-practice-btn {
            background: #3B82F6;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 20px 40px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
        }
        
        .start-practice-btn:hover {
            background: #2563EB;
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.4);
        }
        
        .idle-subtitle {
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-top: 16px;
            text-align: center;
            max-width: 400px;
        }
        
        /* Countdown State */
        .countdown-state {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
        }
        
        .countdown-number {
            font-size: 120px;
            font-weight: 700;
            color: white;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: countdownPulse 1s ease-out;
        }
        
        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .countdown-tip {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            text-align: center;
        }
        
        /* Recording State */
        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 16px;
            height: 16px;
            background: #DC2626;
            border-radius: 50%;
            animation: recordingPulse 2s infinite;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        @keyframes recordingPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }
        
        .stop-btn {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: #DC2626;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 8px 24px rgba(220, 38, 38, 0.3);
        }
        
        .stop-btn:hover {
            background: #B91C1C;
            transform: translateX(-50%) translateY(-2px);
        }
        
        /* Feedback Cards */
        .feedback-container {
            position: absolute;
            bottom: 120px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .feedback-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            font-weight: 500;
            color: #1F2937;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            transform: translateX(-100%);
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: auto;
            max-width: 300px;
        }
        
        .feedback-card.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .feedback-card.fade-out {
            transform: translateX(0) translateY(-20px);
            opacity: 0;
        }
        
        .feedback-icon {
            font-size: 18px;
            flex-shrink: 0;
        }
        
        .feedback-text {
            flex: 1;
        }
        
        /* Edge Lighting */
        .edge-lighting {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-radius: 12px;
            transition: border-color 0.3s ease;
            pointer-events: none;
            z-index: 1;
        }
        
        .edge-lighting.green { border-color: #10B981; }
        .edge-lighting.yellow { border-color: #F59E0B; }
        .edge-lighting.red { border-color: #EF4444; }
        
        /* Progress Timer */
        .progress-timer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            z-index: 10;
        }
        
        .timer-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 3px solid #3B82F6;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: #1F2937;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .timer-circle::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: conic-gradient(var(--progress-color, #3B82F6 0deg, transparent 0deg));
            z-index: -1;
            transition: background 0.3s ease;
        }
        
        /* Paused State */
        .paused-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }
        
        .paused-content {
            text-align: center;
            color: white;
        }
        
        .paused-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        
        .paused-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .btn-resume {
            background: #3B82F6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-resume:hover {
            background: #2563EB;
            transform: translateY(-1px);
        }
        
        .btn-end {
            background: transparent;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-end:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Session Summary */
        .summary-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }
        
        .summary-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            color: #1F2937;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .summary-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 24px;
            color: #10B981;
        }
        
        .score-rings {
            display: flex;
            justify-content: space-around;
            margin: 32px 0;
        }
        
        .score-ring {
            text-align: center;
        }
        
        .score-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
        }
        
        .score-circle.voice { background: #3B82F6; }
        .score-circle.body { background: #10B981; }
        .score-circle.energy { background: #F59E0B; }
        
        .score-label {
            font-size: 12px;
            font-weight: 500;
            color: #6B7280;
        }
        
        /* Typography */
        .text-xl {
            font-size: 18px;
            font-weight: 600;
        }
        
        .text-m {
            font-size: 16px;
            font-weight: 500;
        }
        
        .text-s {
            font-size: 14px;
            font-weight: 400;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Video container -->
        <div id="videoContainer">
            <video id="video" autoplay muted playsinline></video>
            <canvas id="canvas"></canvas>
            
            <!-- Edge Lighting -->
            <div class="edge-lighting" id="edgeLighting"></div>
            
            <!-- Progress Timer -->
            <div class="progress-timer" id="progressTimer" style="display: none;">
                <div class="timer-circle" id="timerCircle">
                    <span id="timerText">0:00</span>
                </div>
            </div>
            
            <!-- Recording Indicator -->
            <div class="recording-indicator" id="recordingIndicator" style="display: none;"></div>
            
            <!-- Stop Button -->
            <button class="stop-btn" id="stopBtn" style="display: none;">‚èπ End Practice</button>
            
            <!-- Pause Button (optional - you can add this if you want pause functionality) -->
            <button class="stop-btn" id="pauseBtn" style="display: none; right: 120px; background: #F59E0B;">‚è∏ Pause</button>
            
            <!-- Feedback Container -->
            <div class="feedback-container" id="feedbackContainer"></div>
            

            
            <!-- Screen States -->
            <div class="screen-state idle-state" id="idleState">
                <div style="text-align: center;">
                    <button class="start-practice-btn" id="startPracticeBtn">üé§ Start Practice</button>
                    <div class="idle-subtitle">We'll analyze posture, voice & energy in real-time</div>
                </div>
            </div>
            
            <div class="screen-state countdown-state hidden" id="countdownState">
                <div class="countdown-number" id="countdownNumber">3</div>
                <div class="countdown-tip">Sit up straight, smile</div>
        </div>
        
            <div class="screen-state recording-state hidden" id="recordingState">
                <div class="recording-indicator"></div>
                <div class="stop-btn" onclick="stopRecording()">Stop Recording</div>
                </div>

            <div class="screen-state paused-overlay hidden" id="pausedOverlay">
                <div class="paused-content">
                    <div class="paused-title">Practice Paused</div>
                    <div class="paused-buttons">
                        <button class="btn-resume" id="resumeBtn">‚ñ∂ Resume</button>
                        <button class="btn-end" id="endSessionBtn">End Session</button>
                    </div>
                </div>
            </div>
            
            <div class="screen-state summary-overlay hidden" id="summaryOverlay">
                <div class="summary-card">
                    <div class="summary-title">üéâ Great Practice Session!</div>
                    <div class="score-rings">
                        <div class="score-ring">
                            <div class="score-circle voice" id="voiceScore">85%</div>
                            <div class="score-label">Voice</div>
                        </div>
                        <div class="score-ring">
                            <div class="score-circle body" id="bodyScore">92%</div>
                            <div class="score-label">Body</div>
                    </div>
                        <div class="score-ring">
                            <div class="score-circle energy" id="energyScore">78%</div>
                            <div class="score-label">Energy</div>
                </div>
            </div>
                    <div class="text-m" style="margin-top: 24px;">
                        Keep practicing to improve your presentation skills!
                    </div>
                    <button class="btn btn-primary" id="newSessionBtn" style="margin-top: 24px;">Start New Session</button>
                </div>
            </div>
        </div>
        
        <!-- Side panel -->
        <div class="side-panel">
            <!-- Status -->
            <div class="status-badge" id="status">
                <span class="dot"></span>
                <span id="statusText">Offline</span>
            </div>
            
            <!-- Live Transcription -->
            <div class="card">
                <div class="card-title">
                    üé§ Live Transcription
                </div>
                <div class="card-content">
                    <div id="currentTranscription">
                        <div id="transcriptionText">Click "Start Practice" and speak...</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                        <div class="analysis-progress" id="analysisProgress" style="display: none;"></div>
                    </div>

                </div>
            </div>
            
            <!-- Speech Analysis -->
            <div class="card">
                <div class="card-title">üí¨ Speech Analysis</div>
                <div class="card-content">
                    <div id="analysisContent">Analysis will appear every 10 seconds...</div>
                </div>
            </div>
            
            <!-- Body Language -->
            <div class="card">
                <div class="card-title">üë§ Body Language</div>
                <div class="card-content">
                    <div class="metrics-grid">
                        <div class="metric-item" id="emotionMetric">
                            <span class="icon">üòê</span>
                            <span>Neutral</span>
                        </div>
                        <div class="metric-item" id="postureMetric">
                            <span class="icon">üìè</span>
                            <span>Good</span>
                        </div>
                        <div class="metric-item" id="fatigueMetric">
                            <span class="icon">‚ö°</span>
                            <span>Alert</span>
                        </div>
                    </div>
                    <div id="bodyLanguageFeedback" style="margin-top: 12px; font-size: 13px; color: rgba(255, 255, 255, 0.8);">
                        Body language feedback will appear here...
                    </div>
                </div>
            </div>
            
            
        </div>
    </div>

    <!-- State-of-the-art emotion detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script>
        console.log('MediaPipe Face Mesh loaded for accurate emotion detection');
    </script>
    <script src="body_language.js"></script>

    <script>
        let ws = null;
        let recognition = null;
        let isRecording = false;
        let isCameraActive = false;
        let sessionStartTime = 0;
        let sessionDuration = 0;
        let isPaused = false;
        let feedbackQueue = [];
        let performanceScore = 0;
        let analysisTimer = null;
        let analysisProgressValue = 0;
        const clientId = Math.floor(Math.random() * 1000);
        
        // Video recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let stream = null;
        let isVideoRecording = false;
        let currentVideoSession = null;
        
        // DOM elements
        const status = document.getElementById('status');
        const statusText = document.getElementById('statusText');
        const transcriptionText = document.getElementById('transcriptionText');
        const analysisContent = document.getElementById('analysisContent');
        const progressFill = document.getElementById('progressFill');
        const analysisProgress = document.getElementById('analysisProgress');
        const bodyLanguageFeedback = document.getElementById('bodyLanguageFeedback');
        const emotionMetric = document.getElementById('emotionMetric');
        const postureMetric = document.getElementById('postureMetric');
        const fatigueMetric = document.getElementById('fatigueMetric');
        
        // Screen state elements
        const idleState = document.getElementById('idleState');
        const countdownState = document.getElementById('countdownState');
        const countdownNumber = document.getElementById('countdownNumber');
        const startPracticeBtn = document.getElementById('startPracticeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const progressTimer = document.getElementById('progressTimer');
        const timerCircle = document.getElementById('timerCircle');
        const timerText = document.getElementById('timerText');
        const pausedOverlay = document.getElementById('pausedOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const endSessionBtn = document.getElementById('endSessionBtn');
        const summaryOverlay = document.getElementById('summaryOverlay');
        const newSessionBtn = document.getElementById('newSessionBtn');
        const feedbackContainer = document.getElementById('feedbackContainer');
        const edgeLighting = document.getElementById('edgeLighting');

        // Check if browser supports speech recognition
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        
        if (!SpeechRecognition) {
            alert('Your browser does not support speech recognition. Please use Chrome, Edge, or Safari.');
        }

        // Video Recording Functions
        async function initializeVideoRecording() {
            try {
                // Get video stream (this is already done by the body language module)
                const videoElement = document.getElementById('video');
                stream = videoElement.srcObject;
                
                if (!stream) {
                    console.error('No video stream available for recording');
                    return false;
                }

                // Create MediaRecorder with video and audio
                const options = {
                    mimeType: 'video/webm;codecs=vp9,opus',
                    videoBitsPerSecond: 2500000, // 2.5 Mbps for good quality
                    audioBitsPerSecond: 128000   // 128 kbps for audio
                };

                try {
                    mediaRecorder = new MediaRecorder(stream, options);
                } catch (e) {
                    // Fallback for older browsers
                    console.warn('VP9 not supported, falling back to VP8');
                    const fallbackOptions = {
                        mimeType: 'video/webm;codecs=vp8,opus',
                        videoBitsPerSecond: 2000000,
                        audioBitsPerSecond: 128000
                    };
                    mediaRecorder = new MediaRecorder(stream, fallbackOptions);
                }

                recordedChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                        console.log('Video chunk recorded:', event.data.size, 'bytes');
                    }
                };

                mediaRecorder.onstop = async () => {
                    console.log('Video recording stopped, processing...');
                    await processRecordedVideo();
                };

                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    showFeedback('Video recording error: ' + event.error, 'negative');
                };

                return true;
            } catch (error) {
                console.error('Failed to initialize video recording:', error);
                showFeedback('Failed to initialize video recording', 'negative');
                return false;
            }
        }

        async function startVideoRecording() {
            try {
                // Start video session on server
                const response = await fetch(`/api/start-video-session/${clientId}`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to start video session');
                }
                
                currentVideoSession = await response.json();
                console.log('Video session started:', currentVideoSession);

                // Initialize recording if not already done
                if (!mediaRecorder) {
                    const recordingReady = await initializeVideoRecording();
                    if (!recordingReady) {
                        throw new Error('Failed to initialize video recording');
                    }
                }

                // Start recording
                recordedChunks = [];
                mediaRecorder.start(1000); // Record in 1-second chunks
                isVideoRecording = true;

                console.log('Video recording started');
                showFeedback('Video recording started', 'info', 3000);

                // Notify server via WebSocket
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'video_session_started',
                        session_id: currentVideoSession.session_id,
                        client_id: clientId
                    }));
                }

                return true;
            } catch (error) {
                console.error('Failed to start video recording:', error);
                showFeedback('Failed to start video recording: ' + error.message, 'negative');
                return false;
            }
        }

        async function stopVideoRecording() {
            try {
                if (!isVideoRecording || !mediaRecorder) {
                    console.log('No video recording in progress');
                    return;
                }

                console.log('Stopping video recording...');
                mediaRecorder.stop();
                isVideoRecording = false;

                showFeedback('Processing video for Twelvelabs analysis...', 'info', 5000);

                // Notify server via WebSocket
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'video_session_ended',
                        session_id: currentVideoSession?.session_id,
                        client_id: clientId
                    }));
                }

            } catch (error) {
                console.error('Error stopping video recording:', error);
                showFeedback('Error stopping video recording', 'negative');
            }
        }

        async function processRecordedVideo() {
            try {
                if (recordedChunks.length === 0) {
                    console.error('No video chunks to process');
                    return;
                }

                console.log('Processing', recordedChunks.length, 'video chunks');
                
                // Create blob from recorded chunks
                const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                console.log('Video blob created, size:', videoBlob.size, 'bytes');

                // Create FormData for upload
                const formData = new FormData();
                formData.append('video', videoBlob, `session_${currentVideoSession?.session_id || 'unknown'}.webm`);

                // Upload to server
                const uploadResponse = await fetch(`/api/upload-video/${clientId}`, {
                    method: 'POST',
                    body: formData
                });

                if (!uploadResponse.ok) {
                    throw new Error('Failed to upload video');
                }

                const uploadResult = await uploadResponse.json();
                console.log('Video uploaded successfully:', uploadResult);

                // End video session and start Twelvelabs analysis
                const endResponse = await fetch(`/api/end-video-session/${clientId}`, {
                    method: 'POST'
                });

                if (!endResponse.ok) {
                    throw new Error('Failed to end video session');
                }

                const endResult = await endResponse.json();
                console.log('Video session ended, analysis starting:', endResult);

                showFeedback('Video uploaded! Deep analysis starting...', 'positive', 4000);

                // Start polling for analysis results
                pollForTwelvelabsResults();

            } catch (error) {
                console.error('Error processing recorded video:', error);
                showFeedback('Error processing video: ' + error.message, 'negative');
            }
        }

        async function pollForTwelvelabsResults() {
            let pollCount = 0;
            const maxPolls = 60; // Poll for up to 10 minutes (60 * 10 seconds)

            const poll = async () => {
                try {
                    pollCount++;
                    
                    const response = await fetch(`/api/video-session/${clientId}`);
                    if (!response.ok) {
                        throw new Error('Failed to get session status');
                    }

                    const session = await response.json();
                    console.log('Session status:', session.status);

                    if (session.status === 'completed') {
                        console.log('Twelvelabs analysis completed!');
                        displayTwelvelabsResults(session.twelvelabs_analysis);
                        return;
                    } else if (session.status === 'error') {
                        console.error('Twelvelabs analysis failed:', session.error);
                        showFeedback('Video analysis failed: ' + session.error, 'negative');
                        return;
                    } else if (pollCount >= maxPolls) {
                        console.warn('Polling timeout reached');
                        showFeedback('Video analysis is taking longer than expected', 'warning');
                        return;
                    }

                    // Update status feedback
                    const statusMessages = {
                        'uploading_to_twelvelabs': 'Uploading to Twelvelabs...',
                        'processing_twelvelabs': 'Processing video...',
                        'analyzing': 'Analyzing content...'
                    };

                    if (statusMessages[session.status]) {
                        showFeedback(statusMessages[session.status], 'info', 3000);
                    }

                    // Continue polling
                    setTimeout(poll, 10000); // Poll every 10 seconds

                } catch (error) {
                    console.error('Error polling for results:', error);
                    if (pollCount < maxPolls) {
                        setTimeout(poll, 10000); // Retry
                    }
                }
            };

            // Start polling
            poll();
        }

        function displayTwelvelabsResults(analysis) {
            console.log('Displaying Twelvelabs analysis:', analysis);
            
            if (!analysis) {
                showFeedback('No analysis results available', 'warning');
                return;
            }

            // Show completion feedback
            showFeedback('üéâ Deep video analysis complete!', 'positive', 5000);

            // Create detailed analysis panel
            const detailedAnalysisHTML = `
                <div style="margin-top: 16px; padding: 16px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                    <h3 style="color: #10B981; margin: 0 0 12px 0; font-size: 16px;">üé¨ Deep Video Analysis</h3>
                    
                    ${analysis.summary ? `
                        <div style="margin-bottom: 12px;">
                            <strong style="color: rgba(255, 255, 255, 0.9);">Summary:</strong>
                            <p style="margin: 4px 0; font-size: 13px; line-height: 1.4; color: rgba(255, 255, 255, 0.8);">${analysis.summary}</p>
                        </div>
                    ` : ''}
                    
                    ${analysis.detailed_insights ? `
                        <div style="margin-bottom: 12px;">
                            <strong style="color: rgba(255, 255, 255, 0.9);">Detailed Insights:</strong>
                            <p style="margin: 4px 0; font-size: 13px; line-height: 1.4; color: rgba(255, 255, 255, 0.8);">${analysis.detailed_insights}</p>
                        </div>
                    ` : ''}
                    
                    ${analysis.recommendations && analysis.recommendations.length > 0 ? `
                        <div style="margin-bottom: 12px;">
                            <strong style="color: rgba(255, 255, 255, 0.9);">Recommendations:</strong>
                            <ul style="margin: 4px 0; padding-left: 16px; font-size: 13px; color: rgba(255, 255, 255, 0.8);">
                                ${analysis.recommendations.map(rec => `
                                    <li style="margin-bottom: 4px;">${rec.recommendation}</li>
                                `).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    <div style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-top: 8px;">
                        Powered by Twelvelabs AI Video Understanding
                    </div>
                </div>
            `;

            // Add to analysis content
            analysisContent.innerHTML += detailedAnalysisHTML;

            // Also show key insights as feedback cards
            if (analysis.recommendations) {
                analysis.recommendations.forEach((rec, index) => {
                    setTimeout(() => {
                        showFeedback(`${rec.category}: ${rec.recommendation}`, 'info', 8000);
                    }, index * 2000); // Stagger the feedback
                });
            }
        }

        // Screen State Management
        function showState(stateElement) {
            // Hide all states
            document.querySelectorAll('.screen-state, .paused-overlay, .summary-overlay').forEach(el => {
                el.classList.add('hidden');
            });
            // Show target state
            stateElement.classList.remove('hidden');
        }

        async function startPractice() {
            // Auto-connect to server if not connected
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                await connect();
            }
            
            showState(countdownState);
            startCountdown();
        }

        function startCountdown() {
            let count = 3;
            countdownNumber.textContent = count;
            
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                    countdownNumber.style.animation = 'none';
                    setTimeout(() => {
                        countdownNumber.style.animation = 'countdownPulse 1s ease-out';
                    }, 10);
                } else {
                    clearInterval(countdownInterval);
                    startRecordingSession();
                }
            }, 1000);
        }

        async function startRecordingSession() {
            sessionStartTime = Date.now();
            sessionDuration = 0;
            performanceScore = 0;
            
            // Hide all screen states to show the video with overlay elements
            document.querySelectorAll('.screen-state, .paused-overlay, .summary-overlay').forEach(el => {
                el.classList.add('hidden');
            });
            
            // Show recording elements
            recordingIndicator.style.display = 'block';
            stopBtn.style.display = 'block';
            pauseBtn.style.display = 'block';  // Show pause button
            progressTimer.style.display = 'block';
            
            // Automatically start camera and body language analysis
            if (!isCameraActive) {
                try {
                    const success = await window.bodyLanguage.start();
                    if (success) {
                        // Set WebSocket reference for body language module
                        if (ws) {
                            window.bodyLanguage.setWebSocket(ws);
                        }
                        isCameraActive = true;
                    }
                } catch (error) {
                    console.error('Camera error:', error.message);
                }
            }
            
            // Start video recording
            await startVideoRecording();
            
            // Start recording immediately
            startRecording();
            
            // Start session timer
            const sessionTimer = setInterval(() => {
                if (!isPaused) {
                    sessionDuration++;
                    updateSessionTimer();
                    updateEdgeLighting();
                }
            }, 1000);
            
            // Store timer reference
            window.sessionTimer = sessionTimer;
        }

        function updateSessionTimer() {
            const minutes = Math.floor(sessionDuration / 60);
            const seconds = sessionDuration % 60;
            timerText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Update circular progress (assuming 5 minute session)
            const progress = (sessionDuration / 300) * 360;
            timerCircle.style.setProperty('--progress', `${progress}deg`);
            timerCircle.style.setProperty('--progress-color', `#3B82F6 ${progress}deg, transparent ${progress}deg`);
        }

        function updateEdgeLighting() {
            // Calculate performance score based on recent feedback
            const recentFeedback = feedbackQueue.slice(-5);
            const positiveCount = recentFeedback.filter(f => f.type === 'positive').length;
            const negativeCount = recentFeedback.filter(f => f.type === 'negative').length;
            
            if (positiveCount > negativeCount) {
                edgeLighting.className = 'edge-lighting green';
            } else if (negativeCount > positiveCount) {
                edgeLighting.className = 'edge-lighting red';
            } else {
                edgeLighting.className = 'edge-lighting yellow';
            }
        }

        function pauseSession() {
            isPaused = true;
            showState(pausedOverlay);
            if (recognition && isRecording) {
                recognition.stop();
            }
            // Note: We don't pause video recording as it's better to have continuous video
        }

        function resumeSession() {
            isPaused = false;
            // Hide all screen states to show the video with overlay elements
            document.querySelectorAll('.screen-state, .paused-overlay, .summary-overlay').forEach(el => {
                el.classList.add('hidden');
            });
            startRecording();
        }

        async function endSession() {
            // Stop recording
            if (recognition && isRecording) {
                recognition.stop();
            }
            
            // Stop video recording
            await stopVideoRecording();
            
            // Clear timers
            if (window.sessionTimer) {
                clearInterval(window.sessionTimer);
            }
            
            // Calculate scores
            calculateSessionScores();
            
            // Show summary
            showState(summaryOverlay);
        }

        function calculateSessionScores() {
            // Calculate scores based on feedback and metrics
            const voiceScore = Math.min(100, Math.max(0, 85 + (performanceScore * 5)));
            const bodyScore = Math.min(100, Math.max(0, 92 + (performanceScore * 3)));
            const energyScore = Math.min(100, Math.max(0, 78 + (performanceScore * 4)));
            
            document.getElementById('voiceScore').textContent = `${Math.round(voiceScore)}%`;
            document.getElementById('bodyScore').textContent = `${Math.round(bodyScore)}%`;
            document.getElementById('energyScore').textContent = `${Math.round(energyScore)}%`;
        }

        function resetSession() {
            // Reset all states
            showState(idleState);
            recordingIndicator.style.display = 'none';
            stopBtn.style.display = 'none';
            pauseBtn.style.display = 'none';  // Hide pause button
            progressTimer.style.display = 'none';
            edgeLighting.className = 'edge-lighting';
            
            // Reset analysis timer
            resetAnalysisTimer();
            
            // Stop camera if active
            if (isCameraActive) {
                const videoElement = document.getElementById('video');
                const stream = videoElement ? videoElement.srcObject : null;
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    videoElement.srcObject = null;
                }
                isCameraActive = false;
            }
            
            // Clear feedback
            feedbackContainer.innerHTML = '';
            feedbackQueue = [];
            
            // Reset variables
            isRecording = false;
            isPaused = false;
            sessionDuration = 0;
            performanceScore = 0;
            isVideoRecording = false;
            currentVideoSession = null;
            recordedChunks = [];
            mediaRecorder = null;
        }

        // Feedback System
        function showFeedback(message, type = 'info', duration = 6000) {
            const feedback = {
                message,
                type,
                timestamp: Date.now()
            };
            
            feedbackQueue.push(feedback);
            
            // Keep only last 10 feedback items
            if (feedbackQueue.length > 10) {
                feedbackQueue.shift();
            }
            
            // Create feedback card
            const card = document.createElement('div');
            card.className = 'feedback-card';
            
            const icon = getFeedbackIcon(type);
            card.innerHTML = `
                <div class="feedback-icon">${icon}</div>
                <div class="feedback-text">${message}</div>
            `;
            
            feedbackContainer.appendChild(card);
            
            // Animate in
            setTimeout(() => {
                card.classList.add('show');
            }, 100);
            
            // Auto-dismiss
            setTimeout(() => {
                card.classList.add('fade-out');
                setTimeout(() => {
                    if (card.parentNode) {
                        card.parentNode.removeChild(card);
                    }
                }, 300);
            }, duration);
            
            // Update performance score
            if (type === 'positive') {
                performanceScore += 1;
            } else if (type === 'negative') {
                performanceScore -= 1;
            }
        }

        function getFeedbackIcon(type) {
            const icons = {
                positive: 'üëç',
                warning: '‚ö†Ô∏è',
                negative: '‚õî',
                info: 'üí°'
            };
            return icons[type] || icons.info;
        }

        function connect() {
            return new Promise((resolve, reject) => {
            ws = new WebSocket(`ws://localhost:8000/ws/text/${clientId}`);

            ws.onopen = () => {
                    status.className = 'status-badge connected';
                    statusText.textContent = `Client #${clientId}`;
                    
                    // Start heartbeat to keep connection alive
                    const heartbeat = setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'heartbeat',
                                client_id: clientId,
                                timestamp: new Date().toISOString()
                            }));
                        } else {
                            clearInterval(heartbeat);
                        }
                    }, 30000); // Send heartbeat every 30 seconds
                    
                    resolve();
            };

            ws.onmessage = (event) => {
                console.log('WebSocket message received:', event.data);
                try {
                const data = JSON.parse(event.data);
                    console.log('Parsed message data:', data);
                    
                if (data.type === 'response') {
                    // Don't show character count messages
                        console.log('Response message ignored');
                } else if (data.type === 'analysis') {
                        console.log('Speech analysis received:', data);
                    displayAnalysis(data);
                } else if (data.type === 'body_language_feedback') {
                        console.log('Body language feedback received:', data);
                    displayBodyLanguageFeedback(data);
                } else if (data.type === 'video_session_acknowledged') {
                    console.log('Video session acknowledged:', data);
                    showFeedback('Video recording session started', 'positive', 3000);
                } else if (data.type === 'twelvelabs_analysis_status') {
                    console.log('Twelvelabs analysis status:', data);
                    const statusMessage = `Analysis status: ${data.status}`;
                    showFeedback(statusMessage, 'info', 4000);
                } else if (data.type === 'twelvelabs_analysis_complete') {
                    console.log('Twelvelabs analysis complete:', data);
                    displayTwelvelabsResults(data.analysis);
                    } else {
                        console.log('Unknown message type:', data.type, data);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error, event.data);
                }
            };

            ws.onerror = (error) => {
                    reject(error);
            };

            ws.onclose = () => {
                    status.className = 'status-badge';
                    statusText.textContent = 'Offline';
                ws = null;
            };
            });
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        // Event Listeners
        startPracticeBtn.onclick = startPractice;
        stopBtn.onclick = endSession;  // Fixed: Stop button should end session, not pause
        pauseBtn.onclick = pauseSession;  // Pause button for pausing session
        resumeBtn.onclick = resumeSession;
        endSessionBtn.onclick = endSession;
        newSessionBtn.onclick = resetSession;







        // Listen for body language data updates to update UI
        window.addEventListener('bodyLanguageUpdate', (event) => {
            const { emotion, posture, fatigue } = event.detail;
            updateBodyLanguageMetrics(emotion, posture, fatigue);
        });

        // Enable body language analysis on load
        window.addEventListener('load', () => {
            console.log('Face detection ready - will start automatically with practice');
        });

        // Update existing functions to integrate with feedback system
        function displayAnalysis(data) {
            console.log('Displaying analysis:', data.analysis_number, data.text);
            
            // Complete the loading bar when analysis arrives
            if (analysisTimer) {
                clearInterval(analysisTimer);
                analysisTimer = null;
            }
            analysisProgress.style.display = 'none';
            progressFill.style.display = 'block';
            analysisProgressValue = 0;
            
            // Clear transcription text and reset for fresh start
            transcriptionText.textContent = 'Listening...';
            transcriptionText.innerHTML = 'Listening...';
            
            // Reset the global transcript for next analysis cycle
            if (window.currentFinalTranscript !== undefined) {
                window.currentFinalTranscript = '';
            }
            
            // Start new timer for next analysis
            startAnalysisTimer();
            
            const analysisDiv = document.createElement('div');
            analysisDiv.className = 'analysis-item';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'analysis-header';
            
            const numberDiv = document.createElement('div');
            numberDiv.className = 'analysis-number';
            numberDiv.textContent = `Analysis #${data.analysis_number || 1}`;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'analysis-time';
            timeDiv.textContent = new Date(data.timestamp).toLocaleTimeString();
            
            headerDiv.appendChild(numberDiv);
            headerDiv.appendChild(timeDiv);
            
            const textDiv = document.createElement('div');
            textDiv.className = 'analysis-text';
            textDiv.textContent = data.text;
            
            const metaDiv = document.createElement('div');
            metaDiv.className = 'analysis-meta';
            const wordCount = data.transcript_analyzed.split(' ').length;
            metaDiv.textContent = `${wordCount} words analyzed`;
            
            analysisDiv.appendChild(headerDiv);
            analysisDiv.appendChild(textDiv);
            analysisDiv.appendChild(metaDiv);
            
            // Replace old analysis with new one
                analysisContent.innerHTML = '';
            analysisContent.appendChild(analysisDiv);
            

            
            // Show feedback based on analysis content
            const analysisText = data.text.toLowerCase();
            if (analysisText.includes('great') || analysisText.includes('good') || analysisText.includes('improved')) {
                showFeedback('Great progress! Keep it up!', 'positive');
            } else if (analysisText.includes('slow') || analysisText.includes('pace')) {
                showFeedback('Try slowing your pace by ~10%', 'warning');
            } else if (analysisText.includes('volume') || analysisText.includes('speak')) {
                showFeedback('Speak a bit louder', 'warning');
            } else if (analysisText.includes('filler') || analysisText.includes('um')) {
                showFeedback('Try reducing filler words', 'warning');
            }
        }

        function displayBodyLanguageFeedback(data) {
            bodyLanguageFeedback.textContent = data.text;
            
            // Show feedback based on body language
            const feedbackText = data.text.toLowerCase();
            if (feedbackText.includes('good') || feedbackText.includes('excellent') || feedbackText.includes('great')) {
                showFeedback('Excellent body language!', 'positive');
            } else if (feedbackText.includes('posture') || feedbackText.includes('straight')) {
                showFeedback('Sit up straight for better presence', 'warning');
            } else if (feedbackText.includes('eye contact')) {
                showFeedback('Hold eye contact with the camera', 'warning');
            } else if (feedbackText.includes('energy') || feedbackText.includes('tired')) {
                showFeedback('Try to show more energy', 'warning');
            }
        }

        function updateBodyLanguageMetrics(emotion, posture, fatigue) {
            // Update emotion metric with emoji and color
            const emotionIcon = getEmotionIcon(emotion);
            const emotionClass = getEmotionClass(emotion);
            emotionMetric.innerHTML = `<span class="icon">${emotionIcon}</span><span>${emotion}</span>`;
            emotionMetric.className = `metric-item ${emotionClass}`;

            // Update posture metric
            const postureIcon = 'üìè';
            const postureClass = getPostureClass(posture.label);
            postureMetric.innerHTML = `<span class="icon">${postureIcon}</span><span>${posture.label}</span>`;
            postureMetric.className = `metric-item ${postureClass}`;

            // Update fatigue metric
            const fatigueIcon = '‚ö°';
            const fatigueClass = getFatigueClass(fatigue.label);
            fatigueMetric.innerHTML = `<span class="icon">${fatigueIcon}</span><span>${fatigue.label}</span>`;
            fatigueMetric.className = `metric-item ${fatigueClass}`;
            
            // Show real-time feedback based on metrics
            if (emotion === 'happy') {
                showFeedback('Great energy! Keep smiling!', 'positive', 4000);
            } else if (posture.label === 'poor') {
                showFeedback('Adjust your posture', 'warning', 4000);
            } else if (fatigue.label === 'tired') {
                showFeedback('Show more enthusiasm', 'warning', 4000);
            }
        }

        function getEmotionIcon(emotion) {
            const icons = {
                'happy': 'üòÑ',
                'sad': 'üòû',
                'angry': 'üò†',
                'surprised': 'üò≤',
                'fearful': 'üò®',
                'disgusted': 'ü§¢',
                'neutral': 'üòê'
            };
            return icons[emotion] || 'üòê';
        }

        function getEmotionClass(emotion) {
            if (['happy', 'surprised'].includes(emotion)) return 'happy';
            if (['sad', 'angry', 'fearful', 'disgusted'].includes(emotion)) return 'sad';
            return 'neutral';
        }

        function getPostureClass(posture) {
            if (['excellent', 'good'].includes(posture)) return 'good';
            if (posture === 'poor') return 'poor';
            return 'fair';
        }

        function getFatigueClass(fatigue) {
            if (fatigue === 'alert') return 'alert';
            if (fatigue === 'tired') return 'tired';
            if (fatigue === 'very tired') return 'very-tired';
            return 'alert';
        }



        function startAnalysisTimer() {
            analysisProgressValue = 0;
            analysisProgress.style.display = 'block';
            progressFill.style.display = 'none';
            
            analysisTimer = setInterval(() => {
                analysisProgressValue += 1;
                analysisProgress.style.width = `${analysisProgressValue}%`;
                
                // Don't complete the bar - wait for actual analysis
                if (analysisProgressValue >= 100) {
                    analysisProgressValue = 100;
                    analysisProgress.style.width = '100%';
                    console.log('Analysis timer completed - waiting for backend analysis...');
                }
            }, 100); // 10 seconds total (100 * 100ms)
        }
        
        function resetAnalysisTimer() {
            if (analysisTimer) {
                clearInterval(analysisTimer);
                analysisTimer = null;
            }
            analysisProgressValue = 0;
            analysisProgress.style.display = 'none';
            progressFill.style.display = 'block';
        }

        function startRecording() {
            if (!SpeechRecognition) {
                console.error('Speech recognition not supported');
                return;
            }

            console.log('Starting speech recognition...');
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            let finalTranscript = '';
            let lastSentIndex = 0;
            
            // Make finalTranscript accessible to displayAnalysis function
            window.currentFinalTranscript = finalTranscript;

            recognition.onstart = () => {
                console.log('Speech recognition started');
                isRecording = true;
                transcriptionText.textContent = 'Listening...';
                startAnalysisTimer();
            };

            recognition.onresult = (event) => {
                console.log('Speech recognition result:', event.results.length, 'results');
                let interimTranscript = '';
                let currentTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    console.log(`Result ${i}: "${transcript}" (final: ${event.results[i].isFinal})`);
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                        currentTranscript = finalTranscript;
                        window.currentFinalTranscript = finalTranscript;
                    } else {
                        interimTranscript += transcript;
                        currentTranscript = finalTranscript + interimTranscript;
                    }
                }
                
                // Stream ALL text (final + interim) to backend continuously
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const message = {
                        type: 'streaming_transcription',
                        text: currentTranscript.trim(),
                        is_final: interimTranscript === '',
                        client_id: clientId,
                        timestamp: new Date().toISOString()
                    };
                    console.log('Sending transcription to server:', message);
                    ws.send(JSON.stringify(message));
                } else {
                    console.log('WebSocket not ready. State:', ws ? ws.readyState : 'null');
                }
                
                // Update the display with both final and interim results
                transcriptionText.innerHTML = 
                    finalTranscript + 
                    '<span class="highlight">' + interimTranscript + '</span>';
                
                // Auto-scroll to bottom
                const transcriptionContainer = document.getElementById('currentTranscription');
                transcriptionContainer.scrollTop = transcriptionContainer.scrollHeight;
            };

            recognition.onerror = (event) => {
                if (event.error === 'no-speech') {
                    transcriptionText.textContent = 'No speech detected. Please try again.';
                }
            };

            recognition.onend = () => {
                console.log('Speech recognition ended');
                
                // Send any remaining text
                const remainingText = finalTranscript.substring(lastSentIndex);
                if (remainingText.trim() && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'final_transcription',
                        text: remainingText.trim(),
                        client_id: clientId,
                        timestamp: new Date().toISOString()
                    }));
                }

                // Restart recognition if still in recording state
                if (isRecording && !isPaused) {
                    console.log('Restarting speech recognition...');
                    setTimeout(() => {
                        try {
            recognition.start();
                        } catch (error) {
                            console.error('Failed to restart recognition:', error);
                        }
                    }, 100);
            } else {
                    isRecording = false;
                    progressFill.style.width = '0%';
                }
            };

            recognition.start();
        }

        function stopRecording() {
            if (recognition && isRecording) {
                recognition.stop();
            }
        }
    </script>
</body>
</html>